#include "desktop.h"
#include "keymap.h"
#include <QThread>
#include <QPoint>
#include <QSize>
#include <unistd.h> // write
#include <string.h> // memset, strcpy
#include <fcntl.h> // open
#include <ctime> // time
#include <opencv2/opencv.hpp>
#include <linux/uinput.h>
#include <X11/Xlib.h> // Import X11 stuff always last. Otherwise compilation fails.
#include <X11/Xutil.h>

/*
 * This implementation uses Xlib and uinput functionality to send keyboard and mouse input events
 * accepted by all kinds of windows. Events generated by xlib are sometimes ignored by programs
 * as those are marked as fake input. Uinput on the other hand is for hardware manifactures. We
 * register a custom universal input device and use it to avoid Xlibs restrictions.
 */

class DesktopPrivate {
public:
	Display *display;
	Window root;
	struct uinput_setup usetup;
	int fd;
	
	void emitEvent(int type, int code, int val)
	{
		struct input_event ie;
		
		ie.type = type;
		ie.code = code;
		ie.value = val;
		
		// Timestamp values below can be ignored (by setting them to 0)
		ie.time.tv_sec = std::time(0);
		ie.time.tv_usec = 0;
		
		write(fd, &ie, sizeof(ie));
	}
	
	void moveCursor(int delta_x, int delta_y)
	{
		emitEvent(EV_REL, REL_X, delta_x);
		emitEvent(EV_REL, REL_Y, delta_y);
		emitEvent(EV_SYN, SYN_REPORT, 0);
	}
	
	void hold(int keycode)
	{
		emitEvent(EV_KEY, keycode, 1);
		emitEvent(EV_SYN, SYN_REPORT, 0);
	}
	
	void release(int keycode)
	{
		emitEvent(EV_KEY, keycode, 0);
		emitEvent(EV_SYN, SYN_REPORT, 0);
	}
	
	void press(int keycode)
	{
		hold(keycode);
		release(keycode);
	}
	
	QSize getSize()
	{
		XWindowAttributes attributes;
		XGetWindowAttributes(display, root, &attributes);
		return QSize(attributes.width, attributes.height);
	}
};

Desktop::Desktop(QObject *parent) : QObject(parent), d_ptr(new DesktopPrivate)
{
	// Uinput is a writable file which contains all mouse and keybord inputs.
	// They are preocessed by the kernel and then interpreted by the userspace.
	d_ptr->fd = open("/dev/uinput", O_WRONLY | O_NONBLOCK);
	
	// Enable key and relative events
	ioctl(d_ptr->fd, UI_SET_EVBIT, EV_KEY);
	ioctl(d_ptr->fd, UI_SET_EVBIT, EV_REL);
	
	// Enable key input events
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_1); // 1
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_2); // 2
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_3); // 3
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_4); // 4
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_5); // 5
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_6); // 6
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_7); // 7
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_8); // 8
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_9); // 9
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_0); // 0
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_A); // A
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_B); // B
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_C); // C
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_D); // D
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_E); // E
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F); // F
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_G); // G
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_H); // H
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_I); // I
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_J); // J
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_K); // K
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_L); // L
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_M); // M
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_N); // N
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_O); // O
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_P); // P
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_Q); // Q
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_R); // R
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_S); // S
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_T); // T
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_U); // U
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_V); // V
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_W); // W
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_X); // X
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_Y); // Y
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_Z); // Z
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_LEFTALT); // LEFT ALT
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_LEFTCTRL); // LEFT CTRL
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_LEFTSHIFT); // LEFT SHIFT
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_RIGHTALT); // RIGHT ALT
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_RIGHTCTRL); // RIGHT CTRL
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_RIGHTSHIFT); // RIGHT SHIFT
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_SLASH); // SLASH
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_BACKSLASH); // BACKSLASH
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_COMMA); // COMMA
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_DOT); // DOT
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_SPACE); // SPACE
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_BACKSPACE); // {BACKSPACE}, {BS}, or {BKSP} 
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_BREAK); // {BREAK} 
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_CAPSLOCK); // {CAPSLOCK}
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_DELETE); // {DELETE} or {DEL} 
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_DOWN); // {DOWN}
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_END); // {END}
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_ENTER); // ENTER {ENTER}or ~
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_ESC); // ESC {ESC}
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_LEFT); // LEFT ARROW {LEFT}
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_PAGEDOWN); // PAGE DOWN {PGDN}
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_PAGEUP); // PAGE UP {PGUP}
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_RIGHT); // RIGHT ARROW {RIGHT}
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_TAB); // TAB {TAB}
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_UP); // UP ARROW {UP}
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F1); // F1 {F1}
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F2); // F2 {F2}
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F3); // F2 F3 {F3}
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F4); // F2 F4 {F4}	
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F5); // F2 F5 {F5}	
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F6); // F2 F6 {F6}	
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F7); // F2 F7 {F7}	
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F8); // F2 F8 {F8}	
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F9); // F2 F9 {F9}	
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F10); // F2 F10 {F10}	
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F11); // F2 F11 {F11}	
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F12); // F2 F12 {F12}	
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F13); // F2 F13 {F13}	
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F14); // F2 F14 {F14}	
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F15); // F2 F15 {F15}	
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F16); // F2 F16 {F16}
	
	// Enable mouse movement input
	ioctl(d_ptr->fd, UI_SET_RELBIT, REL_X);
	ioctl(d_ptr->fd, UI_SET_RELBIT, REL_Y);
	
	// Mouse button events (they don't require mouse movement to be enabled)
	ioctl(d_ptr->fd, UI_SET_KEYBIT, BTN_LEFT);
	ioctl(d_ptr->fd, UI_SET_KEYBIT, BTN_RIGHT);
	ioctl(d_ptr->fd, UI_SET_KEYBIT, BTN_MIDDLE);
	ioctl(d_ptr->fd, UI_SET_KEYBIT, BTN_WHEEL);
	ioctl(d_ptr->fd, UI_SET_KEYBIT, BTN_GEAR_DOWN);
	ioctl(d_ptr->fd, UI_SET_KEYBIT, BTN_GEAR_UP);
	
	// Create a fake input device, which is capable of inputting/faking
	// mouse and keyboard inputs.
	memset(&d_ptr->usetup, 0, sizeof(d_ptr->usetup));
	d_ptr->usetup.id.bustype = BUS_USB;
	d_ptr->usetup.id.vendor = 0x1234; // Sample vendor
	d_ptr->usetup.id.product = 0x5678; // Sample product
	strcpy(d_ptr->usetup.name, "BFP Universal Input Device"); // Device name
	
	// Enable the fake input device.
	ioctl(d_ptr->fd, UI_DEV_SETUP, &d_ptr->usetup);
	ioctl(d_ptr->fd, UI_DEV_CREATE);
	
	d_ptr->display = XOpenDisplay(nullptr);
	d_ptr->root = XDefaultRootWindow(d_ptr->display);
}

Desktop::~Desktop()
{
	ioctl(d_ptr->fd, UI_DEV_DESTROY);
	close(d_ptr->fd);
	XCloseDisplay(d_ptr->display);
}

bool Desktop::takeScreenshot(cv::UMat &screenshot)
{
	XWindowAttributes attributes;
	XGetWindowAttributes(d_ptr->display, d_ptr->root, &attributes);
	
	int width = attributes.width;
	int height = attributes.height;
	
	XImage *x_image = XGetImage(d_ptr->display, d_ptr->root, 0, 0, width, height, AllPlanes, ZPixmap);
	int bits_per_pixel = x_image->bits_per_pixel;
	
	cv::Mat mat(height, width, bits_per_pixel > 24 ? CV_8UC4 : CV_8UC3, x_image->data);
	
	if (bits_per_pixel > 24) {
		// Cut off the alpha channel (because there is a chance the image will be completely transparent otherwise).
		// And desktop screenshots usually don't feature any transparency at all.
		cv::cvtColor(mat, mat, cv::COLOR_BGRA2BGR);
	}
	mat.copyTo(screenshot);
	
	XDestroyImage(x_image);
	return true;
}

int Desktop::getWidth()
{
	return d_ptr->getSize().height();
}

int Desktop::getHeight()
{
	return d_ptr->getSize().width();
}

void Desktop::leftClick(int x, int y)
{
	warpCursor(x, y);
	d_ptr->press(BTN_LEFT);
}

void Desktop::middleClick(int x, int y)
{
	warpCursor(x, y);
	d_ptr->press(BTN_MIDDLE);
}

void Desktop::rightClick(int x, int y)
{
	warpCursor(x, y);
	d_ptr->press(BTN_RIGHT);
}

void Desktop::pressKey(QString key) {
	holdKey(key);
	releaseKey(key);
}

void Desktop::holdKey(QString key)
{
	d_ptr->hold(KEYMAP[key.toLower()]);
}

void Desktop::releaseKey(QString key)
{
	d_ptr->release(KEYMAP[key.toLower()]);
}

void Desktop::warpCursor(int x, int y)
{	
	// Using uinput the cursor can only be moved relative to it's current possition as hardware mouse
	// input is naturally relative. (One can move it's mouse as far as he wants in one direction
	// without hitting any physical barrier).
	// The following trick doesn't work: We cant move the mouse relatively -9999 -9999 to get the mouse
	// to the top left corner of the screen. But moving it then by 100 100 doesn't result in the mouse
	// being at 100 100 unfortunately. For some reason it works when the mouse has been placed at 0 0
	// before manually.
	// The Xlib on the otherhand allows us to warp the pointer/cursor to a absolute position. But
	// mouseinput generated by Xlib is flagged as fake input and thus ignored by some programs,
	// particulary games.
	// We use a combined efford to move the mouse to the desired position while hacing it accepted by all
	// programs: We move the mouse using xlib to the desired position and then shake the cursor a little
	// using input to make all programs recognise the cursors new position.
	
	// If dest_w is None, XWarpPointer moves the pointer by the offsets (dest_x, dest_y)
	// relative to the current position of the pointer. https://linux.die.net/man/3/xwarppointer
	XWarpPointer(d_ptr->display, d_ptr->root, d_ptr->root, 0, 0, 0, 0, x, y);
	XFlush(d_ptr->display);
	
	// Shake the mouse using uinput
	d_ptr->moveCursor(10, 10);
	d_ptr->moveCursor(-10, -10);
}

bool Desktop::getCursorPosition(int *x, int *y)
{
	Window returned_window;
	int win_x, win_y;
	unsigned int returned_mask;
	return XQueryPointer(d_ptr->display, d_ptr->root, &returned_window, &returned_window, x, y, &win_x, &win_y, &returned_mask);
}

bool Desktop::keyExists(QString key)
{
	return KEYMAP.contains(key.toLower());
}
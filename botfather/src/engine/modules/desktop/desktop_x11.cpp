#include "desktop.h"
#include "keymap.h"
#include <QThread>
#include <QPoint>
#include <QSize>
#include <unistd.h> // write
#include <string.h> // memset, strcpy
#include <fcntl.h> // open
#include <ctime> // time
#include <linux/uinput.h>
#include <X11/Xlib.h> // Import X11 stuff always last. Otherwise compilation fails.
#include <X11/Xutil.h>

/*
 * This implementation uses Xlib and uinput functionality to send keyboard and mouse input events
 * accepted by all kinds of windows. Events generated by xlib are sometimes ignored by programs
 * as those are marked as fake input. Uinput on the other hand is for hardware manifactures. We
 * register a custom universal input device and use it to avoid Xlibs restrictions.
 */

class DesktopPrivate {
public:
	Display *display;
	Window root;
	struct uinput_setup usetup;
	int fd;
	
	void emitEvent(unsigned short type, unsigned short code, int val)
	{
		struct input_event ie;
		
		ie.type = type;
		ie.code = code;
		ie.value = val;
		
		// Timestamp values below can be ignored (by setting them to 0)
		ie.time.tv_sec = std::time(nullptr);
		ie.time.tv_usec = 0;
		
		write(fd, &ie, sizeof(ie));
	}
	
	void moveCursor(int delta_x, int delta_y)
	{
		emitEvent(EV_REL, REL_X, delta_x);
		emitEvent(EV_REL, REL_Y, delta_y);
		emitEvent(EV_SYN, SYN_REPORT, 0);
	}
	
	void hold(unsigned short keycode)
	{
		emitEvent(EV_KEY, keycode, 1);
		emitEvent(EV_SYN, SYN_REPORT, 0);
	}
	
	void release(unsigned short keycode)
	{
		emitEvent(EV_KEY, keycode, 0);
		emitEvent(EV_SYN, SYN_REPORT, 0);
	}
	
	void press(unsigned short keycode)
	{
		hold(keycode);
		release(keycode);
	}
	
	QSize getSize()
	{
		XWindowAttributes attributes;
		XGetWindowAttributes(display, root, &attributes);
		return QSize(attributes.width, attributes.height);
	}
};

Desktop::Desktop(QObject *parent) : QObject(parent), d_ptr(new DesktopPrivate)
{
	// Uinput is a writable file which contains all mouse and keybord inputs.
	// They are preocessed by the kernel and then interpreted by the userspace.
	d_ptr->fd = open("/dev/uinput", O_WRONLY | O_NONBLOCK);
	
	// Enable key and relative events
	ioctl(d_ptr->fd, UI_SET_EVBIT, EV_KEY);
	ioctl(d_ptr->fd, UI_SET_EVBIT, EV_REL);
	
	// Enable key input events
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_0); // 0
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_1); // 1
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_2); // 2
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_3); // 3
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_4); // 4
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_5); // 5
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_6); // 6
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_7); // 7
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_8); // 8
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_9); // 9
	
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_A); // A
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_B); // B
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_C); // C
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_D); // D
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_E); // E
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F); // F
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_G); // G
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_H); // H
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_I); // I
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_J); // J
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_K); // K
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_L); // L
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_M); // M
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_N); // N
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_O); // O
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_P); // P
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_Q); // Q
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_R); // R
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_S); // S
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_T); // T
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_U); // U
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_V); // V
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_W); // W
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_X); // X
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_Y); // Y
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_Z); // Z
	
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F1); // F1
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F2); // F2
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F3); // F3
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F4); // F4
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F5); // F5
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F6); // F6
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F7); // F7
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F8); // F8
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F9); // F9
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F10); // F10
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F11); // F11
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F12); // F12
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F13); // F13
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F14); // F14
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F15); // F15
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F16); // F16
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F17); // F17
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F18); // F18
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F19); // F19
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F20); // F20
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F21); // F21
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F22); // F22
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F23); // F23
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_F24); // F24
	
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_LEFT); // LEFT
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_RIGHT); // RIGHT
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_UP); // UP
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_DOWN); // DOWN
	
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_LEFTALT); // LEFT ALT
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_RIGHTALT); // RIGHT ALT
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_LEFTSHIFT); // LEFT SHIFT
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_RIGHTSHIFT); // RIGHT SHIFT
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_LEFTCTRL); // LEFT CTRL
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_RIGHTCTRL); // RIGHT CTRL
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_CAPSLOCK); // CAPSLOCK
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_SPACE); // SPACE
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_TAB); // TAB
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_ESC); // ESC
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_BACKSPACE); // BACKSPACE
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_DELETE); // DELETE
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_ENTER); // ENTER
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_VOLUMEUP); // VOLUME UP
	ioctl(d_ptr->fd, UI_SET_KEYBIT, KEY_VOLUMEDOWN); // VOLUME DOWN
	
	// Enable mouse movement input
	ioctl(d_ptr->fd, UI_SET_RELBIT, REL_X);
	ioctl(d_ptr->fd, UI_SET_RELBIT, REL_Y);
	
	// Mouse button events (they don't require mouse movement to be enabled)
	ioctl(d_ptr->fd, UI_SET_KEYBIT, BTN_LEFT);
	ioctl(d_ptr->fd, UI_SET_KEYBIT, BTN_RIGHT);
	ioctl(d_ptr->fd, UI_SET_KEYBIT, BTN_MIDDLE);
	ioctl(d_ptr->fd, UI_SET_KEYBIT, BTN_WHEEL);
	ioctl(d_ptr->fd, UI_SET_KEYBIT, BTN_GEAR_DOWN);
	ioctl(d_ptr->fd, UI_SET_KEYBIT, BTN_GEAR_UP);
	
	// Create a fake input device, which is capable of inputting/faking
	// mouse and keyboard inputs.
	memset(&d_ptr->usetup, 0, sizeof(d_ptr->usetup));
	d_ptr->usetup.id.bustype = BUS_USB;
	d_ptr->usetup.id.vendor = 0x1234; // Sample vendor
	d_ptr->usetup.id.product = 0x5678; // Sample product
	strcpy(d_ptr->usetup.name, "BFP Universal Input Device"); // Device name
	
	// Enable the fake input device.
	ioctl(d_ptr->fd, UI_DEV_SETUP, &d_ptr->usetup);
	ioctl(d_ptr->fd, UI_DEV_CREATE);
	
	d_ptr->display = XOpenDisplay(nullptr);
	d_ptr->root = XDefaultRootWindow(d_ptr->display);
}

Desktop::~Desktop()
{
	ioctl(d_ptr->fd, UI_DEV_DESTROY);
	close(d_ptr->fd);
	XCloseDisplay(d_ptr->display);
}

QImage Desktop::takeScreenshot()
{
	XWindowAttributes attributes;
	XGetWindowAttributes(d_ptr->display, d_ptr->root, &attributes);
	
	unsigned int width = static_cast<unsigned int>(attributes.width);
	unsigned int height = static_cast<unsigned int>(attributes.height);
	
	XImage *x_image = XGetImage(d_ptr->display, d_ptr->root, 0, 0, width, height, AllPlanes, ZPixmap);
	
	QImage::Format format = x_image->bits_per_pixel > 24 ? QImage::Format_ARGB32 : QImage::Format_RGB888;
	
	// TODO: The Qt doc states that an qimages buffer will not get freed by Qt. But on can pass a function that does so.
	// In our case X deletes our data. But this might also mean, that our images are not safe to use. We should make a
	// copy and pass a function that deletes it. Currently doing a copy will result in a mem leak.
	
	QImage qimage = QImage(reinterpret_cast<uchar*>(x_image->data), x_image->width, x_image->height, x_image->bytes_per_line, format);
	
	if (x_image->bits_per_pixel > 24) {
		qimage = qimage.convertToFormat(QImage::Format_RGB888);
	}
	
	XDestroyImage(x_image);
	return qimage;
}

int Desktop::getWidth()
{
	return d_ptr->getSize().height();
}

int Desktop::getHeight()
{
	return d_ptr->getSize().width();
}

void Desktop::leftClick(int x, int y)
{
	warpCursor(x, y);
	d_ptr->press(BTN_LEFT);
}

void Desktop::middleClick(int x, int y)
{
	warpCursor(x, y);
	d_ptr->press(BTN_MIDDLE);
}

void Desktop::rightClick(int x, int y)
{
	warpCursor(x, y);
	d_ptr->press(BTN_RIGHT);
}

void Desktop::pressKey(QString key) {
	holdKey(key);
	releaseKey(key);
}

void Desktop::holdKey(QString key)
{
	d_ptr->hold(static_cast<unsigned short>(KEYMAP[key.toLower()]));
}

void Desktop::releaseKey(QString key)
{
	d_ptr->release(static_cast<unsigned short>(KEYMAP[key.toLower()]));
}

void Desktop::warpCursor(int x, int y)
{	
	// Using uinput the cursor can only be moved relative to it's current possition as hardware mouse
	// input is naturally relative. (One can move it's mouse as far as he wants in one direction
	// without hitting any physical barrier).
	// The following trick doesn't work: We cant move the mouse relatively -9999 -9999 to get the mouse
	// to the top left corner of the screen. But moving it then by 100 100 doesn't result in the mouse
	// being at 100 100 unfortunately. For some reason it works when the mouse has been placed at 0 0
	// before manually.
	// The Xlib on the otherhand allows us to warp the pointer/cursor to a absolute position. But
	// mouseinput generated by Xlib is flagged as fake input and thus ignored by some programs,
	// particulary games.
	// We use a combined efford to move the mouse to the desired position while hacing it accepted by all
	// programs: We move the mouse using xlib to the desired position and then shake the cursor a little
	// using input to make all programs recognise the cursors new position.
	
	// If dest_w is None, XWarpPointer moves the pointer by the offsets (dest_x, dest_y)
	// relative to the current position of the pointer. https://linux.die.net/man/3/xwarppointer
	XWarpPointer(d_ptr->display, d_ptr->root, d_ptr->root, 0, 0, 0, 0, x, y);
	XFlush(d_ptr->display);
	
	// Shake the mouse using uinput
	d_ptr->moveCursor(10, 10);
	d_ptr->moveCursor(-10, -10);
}

bool Desktop::getCursorPosition(int *x, int *y)
{
	Window returned_window;
	int win_x, win_y;
	unsigned int returned_mask;
	return XQueryPointer(d_ptr->display, d_ptr->root, &returned_window, &returned_window, x, y, &win_x, &win_y, &returned_mask);
}

bool Desktop::keyExists(QString key)
{
	return KEYMAP.contains(key.toLower());
}
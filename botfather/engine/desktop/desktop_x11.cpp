#include <fcntl.h>   // open
#include <string.h>  // memset, strcpy
#include <unistd.h>  // write

#include <QCursor>
#include <QPoint>
#include <QSize>
#include <QThread>
#include <ctime>  // time

#include "desktop.hpp"
#include "keymap.hpp"
#include "linux/uinput.hpp"

/* clang-format off */
#include <X11/Xlib.h>  // Import X11 stuff always last. Otherwise compilation fails.
#include <X11/Xutil.h>
/* clang-format on */

/*
 * This implementation uses Xlib and uinput functionality to send keyboard and
 * mouse input events accepted by all kinds of windows. Events generated by xlib
 * are sometimes ignored by programs as those are marked as fake input. Uinput
 * on the other hand is for hardware manifactures. We register a custom
 * universal input device and use it to avoid Xlibs restrictions.
 */

class DesktopPrivate {
   public:
    Display *display;
    Window root;
    struct uinput_setup usetup;
    int fd;

    void emitEvent(unsigned short type, unsigned short code, int val) {
        struct input_event ie;

        ie.type = type;
        ie.code = code;
        ie.value = val;

        // Timestamp values below can be ignored (by setting them to 0)
        ie.time.tv_sec = std::time(nullptr);
        ie.time.tv_usec = 0;

        write(fd, &ie, sizeof(ie));
    }

    void sync() { emitEvent(EV_SYN, SYN_REPORT, 0); }

    void moveCursor(int delta_x, int delta_y) {
        emitEvent(EV_REL, REL_X, delta_x);
        emitEvent(EV_REL, REL_Y, delta_y);
        sync();
    }

    void hold(unsigned short keycode) {
        emitEvent(EV_KEY, keycode, 1);
        sync();
    }

    void release(unsigned short keycode) {
        emitEvent(EV_KEY, keycode, 0);
        sync();
    }

    void scroll(int units, bool horizontal) {
        int direction = horizontal ? REL_HWHEEL : REL_WHEEL;
        emitEvent(EV_REL, direction, units);
        sync();
    }

    QSize getSize() {
        XWindowAttributes attributes;
        XGetWindowAttributes(display, root, &attributes);
        return QSize(attributes.width, attributes.height);
    }
};

Desktop::Desktop(QObject *parent) : QObject(parent), pimpl(new DesktopPrivate) {
    // Uinput is a writable file which contains all mouse and keybord inputs.
    // They are processed by the kernel and then interpreted by the userspace.
    pimpl->fd = open("/dev/uinput", O_WRONLY | O_NONBLOCK);

    // Enable key, relative and sync events
    ioctl(pimpl->fd, UI_SET_EVBIT, EV_KEY);
    ioctl(pimpl->fd, UI_SET_EVBIT, EV_REL);
    ioctl(pimpl->fd, UI_SET_EVBIT, EV_SYN);

    // Enable key input events
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_0);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_1);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_2);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_3);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_4);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_5);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_6);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_7);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_8);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_9);

    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_A);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_B);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_C);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_D);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_E);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_G);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_H);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_I);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_J);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_K);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_L);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_M);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_N);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_O);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_P);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_Q);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_R);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_S);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_T);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_U);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_V);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_W);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_X);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_Y);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_Z);

    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F1);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F2);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F3);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F4);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F5);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F6);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F7);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F8);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F9);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F10);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F11);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F12);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F13);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F14);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F15);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F16);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F17);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F18);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F19);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F20);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F21);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F22);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F23);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F24);

    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_LEFT);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_RIGHT);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_UP);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_DOWN);

    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_LEFTALT);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_RIGHTALT);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_LEFTSHIFT);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_RIGHTSHIFT);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_LEFTCTRL);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_RIGHTCTRL);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_CAPSLOCK);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_SPACE);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_TAB);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_ESC);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_BACKSPACE);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_DELETE);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_ENTER);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_VOLUMEUP);
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_VOLUMEDOWN);

    // Enable mouse movement and scrolling input
    ioctl(pimpl->fd, UI_SET_RELBIT, REL_X);
    ioctl(pimpl->fd, UI_SET_RELBIT, REL_Y);
    ioctl(pimpl->fd, UI_SET_RELBIT, REL_WHEEL);

    // Mouse button events (they don't require mouse movement to be enabled)
    ioctl(pimpl->fd, UI_SET_KEYBIT, BTN_LEFT);
    ioctl(pimpl->fd, UI_SET_KEYBIT, BTN_RIGHT);
    ioctl(pimpl->fd, UI_SET_KEYBIT, BTN_MIDDLE);
    ioctl(pimpl->fd, UI_SET_KEYBIT, BTN_WHEEL);
    ioctl(pimpl->fd, UI_SET_KEYBIT, BTN_GEAR_DOWN);
    ioctl(pimpl->fd, UI_SET_KEYBIT, BTN_GEAR_UP);
    ioctl(pimpl->fd, UI_SET_KEYBIT, BTN_MOUSE);
    ioctl(pimpl->fd, UI_SET_KEYBIT, BTN_TOUCH);
    ioctl(pimpl->fd, UI_SET_KEYBIT, BTN_TOOL_DOUBLETAP);

    // Create a fake input device, which is capable of inputting/faking
    // mouse and keyboard inputs.
    memset(&pimpl->usetup, 0, sizeof(pimpl->usetup));
    pimpl->usetup.id.bustype = BUS_USB;
    pimpl->usetup.id.vendor = 0x1234;                      // Sample vendor
    pimpl->usetup.id.product = 0x5678;                     // Sample product
    strcpy(pimpl->usetup.name, "Universal Input Device");  // Device name

    // Enable the fake input device.
    ioctl(pimpl->fd, UI_DEV_SETUP, &pimpl->usetup);
    ioctl(pimpl->fd, UI_DEV_CREATE);

    pimpl->display = XOpenDisplay(nullptr);
    pimpl->root = XDefaultRootWindow(pimpl->display);
}

Desktop::~Desktop() {
    ioctl(pimpl->fd, UI_DEV_DESTROY);
    close(pimpl->fd);
    XCloseDisplay(pimpl->display);
}

QImage Desktop::takeScreenshot() {
    XWindowAttributes attributes;
    XGetWindowAttributes(pimpl->display, pimpl->root, &attributes);

    unsigned int width = static_cast<unsigned int>(attributes.width);
    unsigned int height = static_cast<unsigned int>(attributes.height);

    XImage *x_image = XGetImage(pimpl->display, pimpl->root, 0, 0, width,
                                height, AllPlanes, ZPixmap);

    QImage::Format format = x_image->bits_per_pixel > 24
                                ? QImage::Format_ARGB32
                                : QImage::Format_RGB888;

    // TODO: The Qt doc states that an qimages buffer will not get freed by Qt.
    // But on can pass a function that does so. In our case X deletes our data.
    // But this might also mean, that our images are not safe to use. We should
    // make a copy and pass a function that deletes it. Currently doing a copy
    // will result in a mem leak.

    QImage qimage =
        QImage(reinterpret_cast<uchar *>(x_image->data), x_image->width,
               x_image->height, x_image->bytes_per_line, format);

    if (x_image->bits_per_pixel > 24) {
        qimage = qimage.convertToFormat(QImage::Format_RGB888);
    }

    XDestroyImage(x_image);
    return qimage;
}

QSize Desktop::getSize() { return pimpl->getSize(); }

void Desktop::pressMouse(Desktop::MouseButtons button) {
    holdMouse(button);
    releaseMouse(button);
}

void Desktop::holdMouse(Desktop::MouseButtons button) {
    switch (button) {
        case Desktop::MouseButtons::left:
            pimpl->hold(BTN_LEFT);
            break;
        case Desktop::MouseButtons::middle:
            pimpl->hold(BTN_MIDDLE);
            break;
        case Desktop::MouseButtons::right:
            pimpl->hold(BTN_RIGHT);
            break;
    }
}

void Desktop::releaseMouse(Desktop::MouseButtons button) {
    switch (button) {
        case Desktop::MouseButtons::left:
            pimpl->release(BTN_LEFT);
            break;
        case Desktop::MouseButtons::middle:
            pimpl->release(BTN_MIDDLE);
            break;
        case Desktop::MouseButtons::right:
            pimpl->release(BTN_RIGHT);
            break;
    }
}

void Desktop::pressKey(const QString &key) {
    holdKey(key);
    releaseKey(key);
}

void Desktop::holdKey(const QString &key) {
    pimpl->hold(static_cast<unsigned short>(KEYMAP[key.toLower()]));
}

void Desktop::releaseKey(const QString &key) {
    pimpl->release(static_cast<unsigned short>(KEYMAP[key.toLower()]));
}

void Desktop::warpCursor(const QPoint &position) {
    // Using uinput, the cursor can only be moved relative to its current
    // position. That's because hardware mouse input is naturally relative.
    // To get absolute mouse movement, we employ a trick.
    // The following trick doesn't work: We can't move the mouse relatively
    // -9999 -9999 to get the mouse to the top left corner of the screen. But
    // moving it then by 100 100 doesn't result in the mouse being at 100 100
    // unfortunately. For some reason it works when the mouse has been placed at
    // 0 0 before manually. Fortunately, the Xlib allows us to warp the
    // pointer/cursor to a absolute position. But mouseinput generated by Xlib
    // is flagged as fake input and thus ignored by some programs, particulary
    // games. We use a combined efford to move the mouse to the desired position
    // while hacing it accepted by all programs: We move the mouse using xlib to
    // the desired position and then shake the cursor a little using input to
    // make all programs recognise the cursors new position.

    // If dest_w is None, XWarpPointer moves the pointer by the offsets (dest_x,
    // dest_y) relative to the current position of the pointer.
    // https://linux.die.net/man/3/xwarppointer
    XWarpPointer(pimpl->display, pimpl->root, pimpl->root, 0, 0, 0, 0,
                 position.x(), position.y());
    XFlush(pimpl->display);

    // Shake the mouse using uinput
    pimpl->moveCursor(10, 10);
    pimpl->moveCursor(-10, -10);
}

bool Desktop::getCursorPosition(int *x, int *y) {
    QPoint position = QCursor::pos();
    *x = position.x();
    *y = position.y();
    return true;
}

void Desktop::scroll(int units, bool horizontal) {
    pimpl->scroll(units, horizontal);
}

bool Desktop::keyExists(const QString &key) {
    return KEYMAP.contains(key.toLower());
}

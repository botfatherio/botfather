#include <fcntl.h>   // open
#include <string.h>  // memset, strcpy
#include <unistd.h>  // write

#include <QPoint>
#include <QSize>
#include <QThread>
#include <ctime>  // time

#include "desktop.hpp"
#include "keymap.hpp"
#include "linux/uinput.hpp"

/* clang-format off */
#include <X11/Xlib.h>  // Import X11 stuff always last. Otherwise compilation fails.
#include <X11/Xutil.h>
/* clang-format on */

/*
 * This implementation uses Xlib and uinput functionality to send keyboard and
 * mouse input events accepted by all kinds of windows. Events generated by xlib
 * are sometimes ignored by programs as those are marked as fake input. Uinput
 * on the other hand is for hardware manifactures. We register a custom
 * universal input device and use it to avoid Xlibs restrictions.
 */

class DesktopPrivate {
   public:
    Display *display;
    Window root;
    struct uinput_setup usetup;
    int fd;

    void emitEvent(unsigned short type, unsigned short code, int val) {
        struct input_event ie;

        ie.type = type;
        ie.code = code;
        ie.value = val;

        // Timestamp values below can be ignored (by setting them to 0)
        ie.time.tv_sec = std::time(nullptr);
        ie.time.tv_usec = 0;

        write(fd, &ie, sizeof(ie));
    }

    void sync() { emitEvent(EV_SYN, SYN_REPORT, 0); }

    void moveCursor(int delta_x, int delta_y) {
        emitEvent(EV_REL, REL_X, delta_x);
        emitEvent(EV_REL, REL_Y, delta_y);
        sync();
    }

    void hold(unsigned short keycode) {
        emitEvent(EV_KEY, keycode, 1);
        sync();
    }

    void release(unsigned short keycode) {
        emitEvent(EV_KEY, keycode, 0);
        sync();
    }

    void scroll(int units, bool horizontal) {
        int direction = horizontal ? REL_HWHEEL : REL_WHEEL;
        emitEvent(EV_REL, direction, units);
        sync();
    }

    QSize getSize() {
        XWindowAttributes attributes;
        XGetWindowAttributes(display, root, &attributes);
        return QSize(attributes.width, attributes.height);
    }
};

Desktop::Desktop(QObject *parent) : QObject(parent), pimpl(new DesktopPrivate) {
    // Uinput is a writable file which contains all mouse and keybord inputs.
    // They are preocessed by the kernel and then interpreted by the userspace.
    pimpl->fd = open("/dev/uinput", O_WRONLY | O_NONBLOCK);

    // Enable key, relative and sync events
    ioctl(pimpl->fd, UI_SET_EVBIT, EV_KEY);
    ioctl(pimpl->fd, UI_SET_EVBIT, EV_REL);
    ioctl(pimpl->fd, UI_SET_EVBIT, EV_SYN);

    // Enable key input events
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_0);  // 0
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_1);  // 1
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_2);  // 2
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_3);  // 3
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_4);  // 4
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_5);  // 5
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_6);  // 6
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_7);  // 7
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_8);  // 8
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_9);  // 9

    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_A);  // A
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_B);  // B
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_C);  // C
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_D);  // D
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_E);  // E
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F);  // F
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_G);  // G
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_H);  // H
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_I);  // I
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_J);  // J
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_K);  // K
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_L);  // L
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_M);  // M
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_N);  // N
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_O);  // O
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_P);  // P
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_Q);  // Q
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_R);  // R
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_S);  // S
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_T);  // T
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_U);  // U
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_V);  // V
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_W);  // W
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_X);  // X
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_Y);  // Y
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_Z);  // Z

    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F1);   // F1
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F2);   // F2
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F3);   // F3
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F4);   // F4
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F5);   // F5
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F6);   // F6
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F7);   // F7
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F8);   // F8
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F9);   // F9
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F10);  // F10
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F11);  // F11
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F12);  // F12
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F13);  // F13
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F14);  // F14
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F15);  // F15
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F16);  // F16
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F17);  // F17
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F18);  // F18
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F19);  // F19
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F20);  // F20
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F21);  // F21
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F22);  // F22
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F23);  // F23
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_F24);  // F24

    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_LEFT);   // LEFT
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_RIGHT);  // RIGHT
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_UP);     // UP
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_DOWN);   // DOWN

    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_LEFTALT);     // LEFT ALT
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_RIGHTALT);    // RIGHT ALT
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_LEFTSHIFT);   // LEFT SHIFT
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_RIGHTSHIFT);  // RIGHT SHIFT
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_LEFTCTRL);    // LEFT CTRL
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_RIGHTCTRL);   // RIGHT CTRL
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_CAPSLOCK);    // CAPSLOCK
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_SPACE);       // SPACE
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_TAB);         // TAB
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_ESC);         // ESC
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_BACKSPACE);   // BACKSPACE
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_DELETE);      // DELETE
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_ENTER);       // ENTER
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_VOLUMEUP);    // VOLUME UP
    ioctl(pimpl->fd, UI_SET_KEYBIT, KEY_VOLUMEDOWN);  // VOLUME DOWN

    // Enable mouse movement and scrolling input
    ioctl(pimpl->fd, UI_SET_RELBIT, REL_X);
    ioctl(pimpl->fd, UI_SET_RELBIT, REL_Y);
    ioctl(pimpl->fd, UI_SET_RELBIT, REL_WHEEL);

    // Mouse button events (they don't require mouse movement to be enabled)
    ioctl(pimpl->fd, UI_SET_KEYBIT, BTN_LEFT);
    ioctl(pimpl->fd, UI_SET_KEYBIT, BTN_RIGHT);
    ioctl(pimpl->fd, UI_SET_KEYBIT, BTN_MIDDLE);
    ioctl(pimpl->fd, UI_SET_KEYBIT, BTN_WHEEL);
    ioctl(pimpl->fd, UI_SET_KEYBIT, BTN_GEAR_DOWN);
    ioctl(pimpl->fd, UI_SET_KEYBIT, BTN_GEAR_UP);
    ioctl(pimpl->fd, UI_SET_KEYBIT, BTN_MOUSE);
    ioctl(pimpl->fd, UI_SET_KEYBIT, BTN_TOUCH);
    ioctl(pimpl->fd, UI_SET_KEYBIT, BTN_TOOL_DOUBLETAP);

    // Create a fake input device, which is capable of inputting/faking
    // mouse and keyboard inputs.
    memset(&pimpl->usetup, 0, sizeof(pimpl->usetup));
    pimpl->usetup.id.bustype = BUS_USB;
    pimpl->usetup.id.vendor = 0x1234;                      // Sample vendor
    pimpl->usetup.id.product = 0x5678;                     // Sample product
    strcpy(pimpl->usetup.name, "Universal Input Device");  // Device name

    // Enable the fake input device.
    ioctl(pimpl->fd, UI_DEV_SETUP, &pimpl->usetup);
    ioctl(pimpl->fd, UI_DEV_CREATE);

    pimpl->display = XOpenDisplay(nullptr);
    pimpl->root = XDefaultRootWindow(pimpl->display);
}

Desktop::~Desktop() {
    ioctl(pimpl->fd, UI_DEV_DESTROY);
    close(pimpl->fd);
    XCloseDisplay(pimpl->display);
}

QImage Desktop::takeScreenshot() {
    XWindowAttributes attributes;
    XGetWindowAttributes(pimpl->display, pimpl->root, &attributes);

    unsigned int width = static_cast<unsigned int>(attributes.width);
    unsigned int height = static_cast<unsigned int>(attributes.height);

    XImage *x_image = XGetImage(pimpl->display, pimpl->root, 0, 0, width,
                                height, AllPlanes, ZPixmap);

    QImage::Format format = x_image->bits_per_pixel > 24
                                ? QImage::Format_ARGB32
                                : QImage::Format_RGB888;

    // TODO: The Qt doc states that an qimages buffer will not get freed by Qt.
    // But on can pass a function that does so. In our case X deletes our data.
    // But this might also mean, that our images are not safe to use. We should
    // make a copy and pass a function that deletes it. Currently doing a copy
    // will result in a mem leak.

    QImage qimage =
        QImage(reinterpret_cast<uchar *>(x_image->data), x_image->width,
               x_image->height, x_image->bytes_per_line, format);

    if (x_image->bits_per_pixel > 24) {
        qimage = qimage.convertToFormat(QImage::Format_RGB888);
    }

    XDestroyImage(x_image);
    return qimage;
}

QSize Desktop::getSize() { return pimpl->getSize(); }

void Desktop::pressMouse(Desktop::MouseButtons button) {
    holdMouse(button);
    releaseMouse(button);
}

void Desktop::holdMouse(Desktop::MouseButtons button) {
    switch (button) {
        case Desktop::MouseButtons::left:
            pimpl->hold(BTN_LEFT);
            break;
        case Desktop::MouseButtons::middle:
            pimpl->hold(BTN_MIDDLE);
            break;
        case Desktop::MouseButtons::right:
            pimpl->hold(BTN_RIGHT);
            break;
    }
}

void Desktop::releaseMouse(Desktop::MouseButtons button) {
    switch (button) {
        case Desktop::MouseButtons::left:
            pimpl->hold(BTN_LEFT);
            break;
        case Desktop::MouseButtons::middle:
            pimpl->hold(BTN_MIDDLE);
            break;
        case Desktop::MouseButtons::right:
            pimpl->hold(BTN_RIGHT);
            break;
    }
}

void Desktop::pressKey(const QString &key) {
    holdKey(key);
    releaseKey(key);
}

void Desktop::holdKey(const QString &key) {
    pimpl->hold(static_cast<unsigned short>(KEYMAP[key.toLower()]));
}

void Desktop::releaseKey(const QString &key) {
    pimpl->release(static_cast<unsigned short>(KEYMAP[key.toLower()]));
}

void Desktop::warpCursor(const QPoint &position) {
    // Using uinput the cursor can only be moved relative to it's current
    // possition as hardware mouse input is naturally relative. (One can move
    // it's mouse as far as he wants in one direction without hitting any
    // physical barrier). The following trick doesn't work: We cant move the
    // mouse relatively -9999 -9999 to get the mouse to the top left corner of
    // the screen. But moving it then by 100 100 doesn't result in the mouse
    // being at 100 100 unfortunately. For some reason it works when the mouse
    // has been placed at 0 0 before manually. The Xlib on the otherhand allows
    // us to warp the pointer/cursor to a absolute position. But mouseinput
    // generated by Xlib is flagged as fake input and thus ignored by some
    // programs, particulary games. We use a combined efford to move the mouse
    // to the desired position while hacing it accepted by all programs: We move
    // the mouse using xlib to the desired position and then shake the cursor a
    // little using input to make all programs recognise the cursors new
    // position.

    // If dest_w is None, XWarpPointer moves the pointer by the offsets (dest_x,
    // dest_y) relative to the current position of the pointer.
    // https://linux.die.net/man/3/xwarppointer
    XWarpPointer(pimpl->display, pimpl->root, pimpl->root, 0, 0, 0, 0,
                 position.x(), position.y());
    XFlush(pimpl->display);

    // Shake the mouse using uinput
    pimpl->moveCursor(10, 10);
    pimpl->moveCursor(-10, -10);
}

bool Desktop::getCursorPosition(int *x, int *y) {
    Window returned_window;
    int win_x, win_y;
    unsigned int returned_mask;
    return XQueryPointer(pimpl->display, pimpl->root, &returned_window,
                         &returned_window, x, y, &win_x, &win_y,
                         &returned_mask);
}

void Desktop::scroll(int units, bool horizontal) {
    pimpl->scroll(units, horizontal);
}

bool Desktop::keyExists(const QString &key) {
    return KEYMAP.contains(key.toLower());
}
